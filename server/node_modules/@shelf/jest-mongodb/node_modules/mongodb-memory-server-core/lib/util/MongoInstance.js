"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoInstance = exports.MongoInstanceEvents = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path = tslib_1.__importStar(require("path"));
const MongoBinary_1 = require("./MongoBinary");
const debug_1 = tslib_1.__importDefault(require("debug"));
const utils_1 = require("./utils");
const semver_1 = require("semver");
const events_1 = require("events");
const mongodb_1 = require("mongodb");
const fs_1 = require("fs");
if (semver_1.lt(process.version, '10.15.0')) {
    console.warn('Using NodeJS below 10.15.0');
}
const log = debug_1.default('MongoMS:MongoInstance');
var MongoInstanceEvents;
(function (MongoInstanceEvents) {
    MongoInstanceEvents["instanceReplState"] = "instanceReplState";
    MongoInstanceEvents["instancePrimary"] = "instancePrimary";
    MongoInstanceEvents["instanceReady"] = "instanceReady";
    MongoInstanceEvents["instanceSTDOUT"] = "instanceSTDOUT";
    MongoInstanceEvents["instanceSTDERR"] = "instanceSTDERR";
    MongoInstanceEvents["instanceClosed"] = "instanceClosed";
    /** Only Raw Error (emitted by mongodProcess) */
    MongoInstanceEvents["instanceRawError"] = "instanceRawError";
    /** Raw Errors and Custom Errors */
    MongoInstanceEvents["instanceError"] = "instanceError";
    MongoInstanceEvents["killerLaunched"] = "killerLaunched";
    MongoInstanceEvents["instanceLaunched"] = "instanceLaunched";
    MongoInstanceEvents["instanceStarted"] = "instanceStarted";
})(MongoInstanceEvents = exports.MongoInstanceEvents || (exports.MongoInstanceEvents = {}));
/**
 * MongoDB Instance Handler Class
 * This Class starts & stops the "mongod" process directly and handles stdout, sterr and close events
 */
class MongoInstance extends events_1.EventEmitter {
    constructor(opts) {
        super();
        /**
         * This boolean is "true" if the instance is elected to be PRIMARY
         */
        this.isInstancePrimary = false;
        /**
         * This boolean is "true" if the instance is successfully started
         */
        this.isInstanceReady = false;
        /**
         * This boolean is "true" if the instance is part of an replset
         */
        this.isReplSet = false;
        this.instanceOpts = Object.assign({}, opts.instance);
        this.binaryOpts = Object.assign({}, opts.binary);
        this.spawnOpts = Object.assign({}, opts.spawn);
        this.on(MongoInstanceEvents.instanceReady, () => {
            this.isInstanceReady = true;
            this.debug('constructor: Instance is ready!');
        });
        this.on(MongoInstanceEvents.instanceError, (err) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.debug(`constructor: Instance has thrown an Error: ${err.toString()}`);
            this.isInstanceReady = false;
            this.isInstancePrimary = false;
            yield this.stop();
        }));
    }
    /**
     * Debug-log with template applied
     * @param msg The Message to log
     */
    debug(msg) {
        var _a;
        const port = (_a = this.instanceOpts.port) !== null && _a !== void 0 ? _a : 'unknown';
        log(`Mongo[${port}]: ${msg}`);
    }
    /**
     * Create an new instance an call method "start"
     * @param opts Options passed to the new instance
     */
    static create(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            log('create: Called .create() method');
            const instance = new this(opts);
            yield instance.start();
            return instance;
        });
    }
    /**
     * Create an array of arguments for the mongod instance
     */
    prepareCommandArgs() {
        var _a;
        this.debug('prepareCommandArgs');
        utils_1.assertion(!utils_1.isNullOrUndefined(this.instanceOpts.port), new Error('"instanceOpts.port" is required to be set!'));
        utils_1.assertion(!utils_1.isNullOrUndefined(this.instanceOpts.dbPath), new Error('"instanceOpts.dbPath" is required to be set!'));
        const result = [];
        result.push('--port', this.instanceOpts.port.toString());
        result.push('--dbpath', this.instanceOpts.dbPath);
        // "!!" converts the value to an boolean (double-invert) so that no "falsy" values are added
        if (!!this.instanceOpts.storageEngine) {
            result.push('--storageEngine', this.instanceOpts.storageEngine);
        }
        if (!!this.instanceOpts.ip) {
            result.push('--bind_ip', this.instanceOpts.ip);
        }
        if (this.instanceOpts.auth) {
            result.push('--auth');
        }
        else {
            result.push('--noauth');
        }
        if (!!this.instanceOpts.replSet) {
            this.isReplSet = true;
            result.push('--replSet', this.instanceOpts.replSet);
        }
        const final = result.concat((_a = this.instanceOpts.args) !== null && _a !== void 0 ? _a : []);
        this.debug('prepareCommandArgs: final arugment array:' + JSON.stringify(final));
        return final;
    }
    /**
     * Create the mongod process
     * @fires MongoInstance#instanceStarted
     */
    start() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.debug('start');
            this.isInstancePrimary = false;
            this.isInstanceReady = false;
            this.isReplSet = false;
            const launch = new Promise((res, rej) => {
                this.once(MongoInstanceEvents.instanceReady, res);
                this.once(MongoInstanceEvents.instanceError, rej);
                this.once(MongoInstanceEvents.instanceClosed, () => {
                    rej(new Error('Instance Exited before being ready and without throwing an error!'));
                });
            });
            const mongoBin = yield MongoBinary_1.MongoBinary.getPath(this.binaryOpts);
            try {
                yield fs_1.promises.access(mongoBin, fs_1.constants.X_OK);
            }
            catch (err) {
                console.error(`Mongod File at "${mongoBin}" does not have sufficient permissions to be used by this process\n` +
                    'Needed Permissions: Execute (--x)\n');
                throw err;
            }
            this.debug('start: Starting Processes');
            this.mongodProcess = this._launchMongod(mongoBin);
            // This assertion is here because somewhere between nodejs 12 and 16 the types for "childprocess.pid" changed to include "| undefined"
            // it is tested and a error is thrown in "this_launchMongod", but typescript somehow does not see this yet as of 4.3.5
            utils_1.assertion(!utils_1.isNullOrUndefined(this.mongodProcess.pid), new Error('MongoD Process failed to spawn'));
            this.killerProcess = this._launchKiller(process.pid, this.mongodProcess.pid);
            yield launch;
            this.emit(MongoInstanceEvents.instanceStarted);
            this.debug('start: Processes Started');
        });
    }
    /**
     * Shutdown all related processes (Mongod Instance & Killer Process)
     */
    stop() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.debug('stop');
            if (!this.mongodProcess && !this.killerProcess) {
                log('stop: nothing to shutdown, returning');
                return false;
            }
            if (!utils_1.isNullOrUndefined(this.mongodProcess)) {
                // try to run "replSetStepDown" before running "killProcess" (gracefull "SIGINT")
                // running "&& this.isInstancePrimary" otherwise "replSetStepDown" will fail with "MongoError: not primary so can't step down"
                if (this.isReplSet && this.isInstancePrimary) {
                    let con;
                    try {
                        log('stop: trying replSetStepDown');
                        const port = this.instanceOpts.port;
                        const ip = this.instanceOpts.ip;
                        utils_1.assertion(!utils_1.isNullOrUndefined(port), new Error('Cannot shutdown replset gracefully, no "port" is provided'));
                        utils_1.assertion(!utils_1.isNullOrUndefined(ip), new Error('Cannot shutdown replset gracefully, no "ip" is provided'));
                        con = yield mongodb_1.MongoClient.connect(utils_1.uriTemplate(ip, port, 'admin'), {
                            useNewUrlParser: true,
                            useUnifiedTopology: true,
                        });
                        const admin = con.db('admin'); // just to ensure it is actually the "admin" database
                        yield admin.command({ replSetStepDown: 1, force: true });
                    }
                    catch (err) {
                        // Quote from MongoDB Documentation (https://docs.mongodb.com/manual/reference/command/replSetStepDown/#client-connections):
                        // > Starting in MongoDB 4.2, replSetStepDown command no longer closes all client connections.
                        // > In MongoDB 4.0 and earlier, replSetStepDown command closes all client connections during the step down.
                        // so error "MongoNetworkError: connection 1 to 127.0.0.1:41485 closed" will get thrown below 4.2
                        if (!(err instanceof mongodb_1.MongoNetworkError &&
                            /^connection \d+ to [\d.]+:\d+ closed$/i.test(err.message))) {
                            console.warn(err);
                        }
                    }
                    finally {
                        if (!utils_1.isNullOrUndefined(con)) {
                            // even if it errors out, somehow the connection stays open
                            yield con.close();
                        }
                    }
                }
                yield utils_1.killProcess(this.mongodProcess, 'mongodProcess');
                this.mongodProcess = undefined; // reset reference to the childProcess for "mongod"
            }
            else {
                this.debug('stop: mongodProcess: nothing to shutdown, skipping');
            }
            if (!utils_1.isNullOrUndefined(this.killerProcess)) {
                yield utils_1.killProcess(this.killerProcess, 'killerProcess');
                this.killerProcess = undefined; // reset reference to the childProcess for "mongo_killer"
            }
            else {
                this.debug('stop: killerProcess: nothing to shutdown, skipping');
            }
            this.debug('stop: Instance Finished Shutdown');
            return true;
        });
    }
    /**
     * Actually launch mongod
     * @param mongoBin The binary to run
     * @fires MongoInstance#instanceLaunched
     */
    _launchMongod(mongoBin) {
        var _a, _b;
        this.debug('_launchMongod: Launching Mongod Process');
        const childProcess = child_process_1.spawn(path.resolve(mongoBin), this.prepareCommandArgs(), Object.assign(Object.assign({}, this.spawnOpts), { stdio: 'pipe' }));
        (_a = childProcess.stderr) === null || _a === void 0 ? void 0 : _a.on('data', this.stderrHandler.bind(this));
        (_b = childProcess.stdout) === null || _b === void 0 ? void 0 : _b.on('data', this.stdoutHandler.bind(this));
        childProcess.on('close', this.closeHandler.bind(this));
        childProcess.on('error', this.errorHandler.bind(this));
        if (utils_1.isNullOrUndefined(childProcess.pid)) {
            throw new Error('Spawned Mongo Instance PID is undefined');
        }
        this.emit(MongoInstanceEvents.instanceLaunched);
        return childProcess;
    }
    /**
     * Spawn an seperate process to kill the parent and the mongod instance to ensure "mongod" gets stopped in any case
     * @param parentPid Parent nodejs process
     * @param childPid Mongod process to kill
     * @fires MongoInstance#killerLaunched
     */
    _launchKiller(parentPid, childPid) {
        this.debug(`_launchKiller: Launching Killer Process (parent: ${parentPid}, child: ${childPid})`);
        // spawn process which kills itself and mongo process if current process is dead
        const killer = child_process_1.fork(path.resolve(__dirname, '../../scripts/mongo_killer.js'), [parentPid.toString(), childPid.toString()], {
            detached: true,
            stdio: 'ignore', // stdio cannot be done with an detached process cross-systems and without killing the fork on parent termination
        });
        killer.unref(); // dont force an exit on the fork when parent is exiting
        this.emit(MongoInstanceEvents.killerLaunched);
        return killer;
    }
    /**
     * Event "error" handler
     * @param err The Error to handle
     * @fires MongoInstance#instanceRawError
     * @fires MongoInstance#instanceError
     */
    errorHandler(err) {
        this.emit(MongoInstanceEvents.instanceRawError, err);
        this.emit(MongoInstanceEvents.instanceError, err);
    }
    /**
     * Write the CLOSE event to the debug function
     * @param code The Exit code to handle
     * @fires MongoInstance#instanceClosed
     */
    closeHandler(code) {
        // check if the platform is windows, if yes check if the code is not "12" or "0" otherwise just check code is not "0"
        // because for mongodb any event on windows (like SIGINT / SIGTERM) will result in an code 12
        // https://docs.mongodb.com/manual/reference/exit-codes/#12
        if ((process.platform === 'win32' && code != 12 && code != 0) || code != 0) {
            this.debug('closeHandler: Mongod instance closed with an non-0 (or non 12 on windows) code!');
        }
        this.debug(`closeHandler: ${code}`);
        this.emit(MongoInstanceEvents.instanceClosed, code);
    }
    /**
     * Write STDERR to debug function
     * @param message The STDERR line to write
     * @fires MongoInstance#instanceSTDERR
     */
    stderrHandler(message) {
        this.debug(`stderrHandler: ""${message.toString()}""`); // denoting the STDERR string with double quotes, because the stdout might also use quotes
        this.emit(MongoInstanceEvents.instanceSTDERR, message);
    }
    /**
     * Write STDOUT to debug function and process some special messages
     * @param message The STDOUT line to write/parse
     * @fires MongoInstance#instanceSTDOUT
     * @fires MongoInstance#instanceReady
     * @fires MongoInstance#instanceError
     * @fires MongoInstance#instancePrimary
     * @fires MongoInstance#instanceReplState
     */
    stdoutHandler(message) {
        var _a, _b, _c, _d;
        const line = message.toString().trim(); // trimming to remove extra new lines and spaces around the message
        this.debug(`stdoutHandler: ""${line}""`); // denoting the STDOUT string with double quotes, because the stdout might also use quotes
        this.emit(MongoInstanceEvents.instanceSTDOUT, line);
        // dont use "else if", because input can be multiple lines and match multiple things
        if (/waiting for connections/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceReady);
        }
        if (/address already in use/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, `Port "${this.instanceOpts.port}" already in use`);
        }
        if (/mongod instance already running/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, 'Mongod already running');
        }
        if (/permission denied/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, 'Mongod permission denied');
        }
        if (/Data directory .*? not found/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, 'Data directory not found');
        }
        if (/CURL_OPENSSL_3['\s]+not found/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, 'libcurl3 is not available on your system. Mongod requires it and cannot be started without it.\n' +
                'You should manually install libcurl3 or try to use an newer version of MongoDB\n');
        }
        if (/CURL_OPENSSL_4['\s]+not found/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, 'libcurl4 is not available on your system. Mongod requires it and cannot be started without it.\n' +
                'You need to manually install libcurl4\n');
        }
        if (/lib[\w-.]+: cannot open shared object/i.test(line)) {
            const lib = (_b = (_a = line.match(/(lib[\w-.]+): cannot open shared object/i)) === null || _a === void 0 ? void 0 : _a[1].toLocaleLowerCase()) !== null && _b !== void 0 ? _b : 'unknown';
            this.emit(MongoInstanceEvents.instanceError, `Instance Failed to start because an library file is missing: "${lib}"`);
        }
        if (/\*\*\*aborting after/i.test(line)) {
            this.emit(MongoInstanceEvents.instanceError, 'Mongod internal error');
        }
        if (/transition to primary complete; database writes are now permitted/i.test(line)) {
            this.isInstancePrimary = true;
            this.debug('stdoutHandler: emitting "instancePrimary"');
            this.emit(MongoInstanceEvents.instancePrimary);
        }
        if (/member [\d\.:]+ is now in state \w+/i.test(line)) {
            // "[\d\.:]+" matches "0.0.0.0:0000" (IP:PORT)
            const state = (_d = (_c = /member [\d\.:]+ is now in state (\w+)/i.exec(line)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : 'UNKNOWN';
            this.emit(MongoInstanceEvents.instanceReplState, state);
            if (state !== 'PRIMARY') {
                this.isInstancePrimary = false;
            }
        }
    }
}
exports.MongoInstance = MongoInstance;
exports.default = MongoInstance;
//# sourceMappingURL=MongoInstance.js.map